<!DOCTYPE html>
<html>
<head>
	<title>color plot</title>
	<style type="text/css">
		canvas{outline: 1px solid blue;}
	</style>
</head>
<body>
	<!-- <canvas width="500" height="500" id="container"></canvas> -->
	<script type="x-shader/x-vertex" id="vertexshaderx">

attribute float r;
attribute float g;
attribute float b;

attribute vec4 c;

varying float vr;
varying float vg;
varying float vb;

varying vec4 vc;


void main() {
	vr = r;
	vg = g;
	vb = b;
	vc = c;
  // cc = vec4(r,g,b,1.0);
  gl_Position = projectionMatrix *
                modelViewMatrix *
                vec4(position,1.0);
}
	</script>
	<script type="x-shader/x-fragment" id="fragmentshaderx">

varying float vr;
varying float vg;
varying float vb;

varying vec4 vc;

void main() {
	gl_FragColor = vec4(vc);//vr, vg, vb, 1.0); 
}
	</script>
<script type="x-shader/x-vertex" id="vertexshader">

	uniform float amplitude;
	uniform float direction;
	attribute float size;
	attribute vec3 customColor;
	attribute vec3 custompositiona;
	attribute vec3 custompositionb;
	uniform float time;

	varying vec3 vColor;
	varying float fAlpha;

	void main() {

		vColor = customColor;

		vec3 pos = position;

		// small noise  movement
		pos.x += cos(time + (position.y/8.0))*50.0; 
		pos.z += sin(time + (position.x/8.0))*50.0; 
		pos.y += sin(time + (position.z/4.0))*40.0; 

		// morph
		vec3 morphed = vec3( 0.0, 0.0, 0.0 );
		if (direction == 0.0) {
			morphed += ( custompositionb - position ) * amplitude;
		} else {
			morphed += ( custompositiona - position ) * amplitude;
		}
		morphed += pos;

		vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );

		fAlpha = (mvPosition.z+6000.0)/6000.0;

		gl_PointSize = min(150.0, size * ( 150.0 / length( mvPosition.xyz ) ) );

		gl_Position = projectionMatrix * mvPosition;

	}

</script>

<script type="x-shader/x-fragment" id="fragmentshader">

	uniform vec3 color;
	uniform sampler2D texture;

	varying vec3 vColor;
	varying float fAlpha;

	void main() {

		vec4 outColor = texture2D( texture, gl_PointCoord );
		if ( outColor.a < 0.5 ) discard; // alpha be gone

		gl_FragColor = outColor * vec4( color * vColor.xyz, fAlpha );


	}

</script>



	<script type="text/javascript" src="/three.js/three.js"></script>
	<script type="text/javascript">

// particles
attributes = {

	size: {	type: 'f', value: [] },
	custompositiona: { type: 'v3', value: [] },
	custompositionb: { type: 'v3', value: [] },
	customColor: { type: 'f', value: [] },


	r:{ type: 'f', value: [] },
	g:{ type: 'f', value: [] },
	b:{ type: 'f', value: [] },


	c:{ type: 'c', value: [] },

};

uniforms = {

	amplitude: { type: "f", value: 0.0 },
	color:     { type: "c", value: new THREE.Color( 0xffffff ) },
	texture:   { type: "t", value: 0, texture: generateTexture(0) },
	time:		{ type: "f", value: 1.0 },
	direction:		{ type: "f", value: 1.0 },

};

var shaderMaterial = new THREE.ShaderMaterial( {

	uniforms: 		uniforms,
	attributes:     attributes,
	vertexShader:   document.getElementById( 'vertexshaderx' ).textContent,
	fragmentShader: document.getElementById( 'fragmentshaderx' ).textContent,

	blending: 		THREE.NormalBlending,
	depthTest: 		true,
	transparent:	false,
	
});


		// container = document.getElementById( 'container' );
var width = window.innerWidth;
var height = window.innerHeight;

var renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(width, height);
renderer.setClearColor(0xf5f5f5, 1);
document.body.appendChild(renderer.domElement);



		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.z = 1000;

		var particleMaterial = new THREE.ParticleBasicMaterial({ 
			transparent: true, size: 10, color: 0xffffff*Math.random()
			// map: generateTexture(0)
		});

		var radius = 200;
		var geometry = new THREE.Geometry();

		for ( var i = 0; i < 10000; i ++ ) {

			var vertex = new THREE.Vector3();
			vertex.x = Math.random() * 2 - 1;
			vertex.y = Math.random() * 2 - 1;
			vertex.z = Math.random() * 2 - 1;
			vertex.z = 0;
			vertex.multiplyScalar( radius );

			geometry.vertices.push( vertex );

			// attributes.customColor.value.push(Math.random()>.5?1.0:0.0)

			// attributes.r.value.push(Math.random())
			// attributes.g.value.push(Math.random())
			// attributes.b.value.push(Math.random())

			attributes.c.value.push(new THREE.Color( 0xffffff*Math.random() ));

		}

		particles = new THREE.ParticleSystem( geometry, shaderMaterial );

		scene.add(particles)


vertices = geometry.vertices;



var values_positiona = attributes.custompositiona.value;
var values_positionb = attributes.custompositionb.value;

for( var v = 0; v < vertices.length; v++ ) {

	var index = v*3;

	// if (index > data1.length) {
	values_positiona[ v ] = getRandomPointOnparticles(400+Math.random()*radius*1.5);
	values_positionb[ v ] = getRandomPointOnparticles(400+Math.random()*radius*1.5);
	// } else {
	// 	var vector = new THREE.Vector3(Math.random(),Math.random(),Math.random());
	// 	vector.multiplyScalar(120);
	// 	values_positiona[ v ] = vector;

	// 	var vector = new THREE.Vector3(Math.random(),Math.random(),Math.random());
	// 	vector.multiplyScalar(170);
	// 	values_positionb[ v ] = vector;
	// }

}
function getRandomPointOnparticles(r) {
	var angle = Math.random() * Math.PI * 2;
	var u = Math.random() * 2 - 1;

	var v = new THREE.Vector3(
		Math.cos(angle) * Math.sqrt(1 - Math.pow(u, 2)) * r,
		Math.sin(angle) * Math.sqrt(1 - Math.pow(u, 2)) * r,
		u * r
	);
	return v;
}


// renderer.render(scene, camera);

function render() {
  requestAnimationFrame(render);

  particles.rotation.y += 0.002;

  // TWEEN.update();
  renderer.render(scene, camera);
}

render()


// to be parameterised
function generateTexture(i){
  var canvas = document.createElement( 'canvas' ),
      size = 20;
  canvas.width = size;
  canvas.height = size;

  var ctx = canvas.getContext( '2d' );

  ctx.fillStyle = i === 0 ? '#f00' :
                  i === 1 ? '#00f' :
                  i === 2 ? '#0f0' : 
                  i === 3 ? '#000' : 
                  i === 4 ? '#fc0' : 
                  '#aaa';


  ctx.fillStyle = 'rgba(255,0,150,1)'

  // ctx.fillStyle = i === 4 ? '#f00' : '#aaa';
  ctx.beginPath();
  ctx.arc(size/2, size/2, size/2,0,Math.PI*2);
  ctx.fill();

  var t = new THREE.Texture( canvas );
  t.needsUpdate = true;
  return t;
}
	</script>
</body>
</html>